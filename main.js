/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SupSubPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  enablePopup: true,
  hideTags: true,
  popupModifierKey: "Mod"
};
var pluginSettings = DEFAULT_SETTINGS;
var tagDecoration = import_view.Decoration.replace({});
var supDecoration = import_view.Decoration.mark({
  attributes: {
    class: "cm-sup"
  }
});
var subDecoration = import_view.Decoration.mark({
  attributes: {
    class: "cm-sub"
  }
});
var supSubDecorationPlugin = import_view.ViewPlugin.define((view) => {
  return {
    decorations: computeDecorations(view),
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet) {
        this.decorations = computeDecorations(update.view);
      }
    }
  };
}, {
  decorations: (v) => v.decorations
});
function computeDecorations(view) {
  if (!pluginSettings.hideTags) {
    return import_view.Decoration.none;
  }
  const doc = view.state.doc;
  const cursorLine = doc.lineAt(view.state.selection.main.head).number;
  const regex = /<(sup|sub)>(.*?)<\/\1>/g;
  const ranges = [];
  for (const { from, to } of view.visibleRanges) {
    regex.lastIndex = 0;
    const text = doc.sliceString(from, to);
    let match;
    while ((match = regex.exec(text)) !== null) {
      const tag = match[1];
      const absFrom = from + match.index;
      const absTo = absFrom + match[0].length;
      const openTagEnd = absFrom + `<${tag}>`.length;
      const closeTagStart = absTo - `</${tag}>`.length;
      const matchLine = doc.lineAt(absFrom).number;
      if (openTagEnd > closeTagStart)
        continue;
      const contentDec = tag === "sup" ? supDecoration : subDecoration;
      if (matchLine === cursorLine) {
        ranges.push(contentDec.range(openTagEnd, closeTagStart));
      } else {
        ranges.push(tagDecoration.range(absFrom, openTagEnd));
        ranges.push(contentDec.range(openTagEnd, closeTagStart));
        ranges.push(tagDecoration.range(closeTagStart, absTo));
      }
    }
  }
  return import_view.Decoration.set(ranges, true);
}
var SupSubSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "SupSub Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Popup Buttons").setDesc("Toggle the visibility of the SupSub popup buttons when text is selected.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePopup).onChange(async (value) => {
      this.plugin.settings.enablePopup = value;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Popup Buttons ${value ? "Enabled" : "Disabled"}`);
      if (!value) {
        this.plugin.hideSupSubButtons();
        this.plugin.selectionStart = null;
        this.plugin.selectionEnd = null;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Hide Sup/Sub Tags").setDesc("Instantly hide the <sup> and <sub> tags in Editor Mode after wrapping.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideTags).onChange(async (value) => {
      this.plugin.settings.hideTags = value;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Hide Tags ${value ? "Enabled" : "Disabled"}`);
      this.plugin.refreshDecorations();
    }));
    new import_obsidian.Setting(containerEl).setName("Popup Modifier Key").setDesc("Require holding a modifier key to show the popup when text is selected. Set to 'None' for the popup to always appear on selection.").addDropdown((dropdown) => dropdown.addOption("Mod", "Cmd / Ctrl (recommended)").addOption("Ctrl", "Ctrl").addOption("Shift", "Shift").addOption("Alt", "Alt").addOption("none", "None (always show)").setValue(this.plugin.settings.popupModifierKey).onChange(async (value) => {
      this.plugin.settings.popupModifierKey = value;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Popup modifier key set to ${value === "none" ? "None" : value}`);
    }));
  }
};
var SupSubPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.styleEl = null;
    this.isWrapping = false;
    this.selectionStart = null;
    this.selectionEnd = null;
    // Modifier key tracking (Issue #9)
    this.modifierKeyPressed = false;
    // Toggle mode state (Issue #10)
    this.toggleMode = null;
    this.toggleStatusBarEl = null;
    this.toggleStartPos = 0;
    this.toggleStartLine = 0;
  }
  async onload() {
    await this.loadSettings();
    pluginSettings = this.settings;
    this.addSettingTab(new SupSubSettingTab(this.app, this));
    this.addCommand({
      id: "wrap-sup",
      name: "Wrap with <sup> tags",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.wrapSelection("sup", editor);
        } else {
          this.toggleTypingMode("sup", editor);
        }
      },
      hotkeys: [{ modifiers: ["Mod", "Alt"], key: "=" }]
    });
    this.addCommand({
      id: "wrap-sub",
      name: "Wrap with <sub> tags",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.wrapSelection("sub", editor);
        } else {
          this.toggleTypingMode("sub", editor);
        }
      },
      hotkeys: [{ modifiers: ["Mod", "Alt"], key: "-" }]
    });
    const style = `
            .supsub-popup {
                position: absolute;
                background: var(--background-primary);
                border: 1px solid var(--border);
                padding: 5px;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                z-index: 10000;
                display: flex;
                gap: 5px;
                transition: opacity 0.1s ease;
                opacity: 0;
                pointer-events: none;
            }
            .supsub-popup.visible {
                opacity: 1;
                pointer-events: auto;
            }
            .supsub-popup button {
                background: var(--background-modifier-hover);
                border: none;
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                transition: background 0.2s ease;
            }
            .supsub-popup button:hover {
                background: var(--background-modifier-hover-active);
            }
            .cm-sup {
                vertical-align: super;
                font-size: smaller;
            }
            .cm-sub {
                vertical-align: sub;
                font-size: smaller;
            }
        `;
    this.styleEl = document.createElement("style");
    this.styleEl.innerText = style;
    document.head.appendChild(this.styleEl);
    this.register(() => {
      if (this.styleEl) {
        this.styleEl.remove();
      }
    });
    this.registerDomEvent(document, "keydown", (evt) => {
      if (this.isModifierMatch(evt)) {
        this.modifierKeyPressed = true;
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && this.settings.enablePopup) {
          const editor = view.editor;
          const selection = editor.getSelection();
          if (selection) {
            this.showSupSubButtons(editor);
          }
        }
      }
      if (evt.key === "Escape" && this.toggleMode) {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view) {
          this.exitToggleMode(view.editor);
        }
      }
    });
    this.registerDomEvent(document, "keyup", (evt) => {
      if (this.isModifierMatch(evt)) {
        this.modifierKeyPressed = false;
        this.hideSupSubButtons();
      }
    });
    this.registerDomEvent(document, "blur", () => {
      this.modifierKeyPressed = false;
    });
    this.registerEvent(this.app.workspace.on("editor-selection-change", (editor) => {
      if (this.isWrapping)
        return;
      if (this.toggleMode) {
        const cursor = editor.getCursor();
        if (cursor.line !== this.toggleStartLine) {
          this.exitToggleMode(editor);
        }
      }
      const selection = editor.getSelection();
      if (selection && this.settings.enablePopup && (this.settings.popupModifierKey === "none" || this.modifierKeyPressed)) {
        this.showSupSubButtons(editor);
      } else {
        this.hideSupSubButtons();
      }
    }));
    this.registerDomEvent(document, "click", (evt) => {
      const target = evt.target;
      if (!target.closest(".supsub-popup")) {
        this.hideSupSubButtons();
      }
    });
    this.registerEditorExtension(supSubDecorationPlugin);
  }
  onunload() {
    this.hideSupSubButtons();
    if (this.styleEl) {
      this.styleEl.remove();
    }
    if (this.toggleStatusBarEl) {
      this.toggleStatusBarEl.remove();
      this.toggleStatusBarEl = null;
    }
    this.toggleMode = null;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    pluginSettings = this.settings;
  }
  refreshDecorations() {
    pluginSettings = this.settings;
    this.app.workspace.updateOptions();
  }
  showSupSubButtons(editor) {
    if (!this.settings.enablePopup)
      return;
    this.hideSupSubButtons();
    const selection = editor.getSelection();
    if (!selection)
      return;
    const cursorStart = editor.getCursor("from");
    const cursorEnd = editor.getCursor("to");
    this.selectionStart = { ...cursorStart };
    this.selectionEnd = { ...cursorEnd };
    let effectiveSelection = selection;
    if (cursorStart.line === cursorEnd.line) {
      const line = editor.getLine(cursorStart.line);
      const tagRegex = /<(sup|sub)>([\s\S]*?)<\/\1>/g;
      let match;
      let bestMatch = null;
      let bestDistance = Infinity;
      while ((match = tagRegex.exec(line)) !== null) {
        const matchStart = match.index;
        const matchEnd = match.index + match[0].length;
        if (cursorStart.ch >= matchStart && cursorEnd.ch <= matchEnd) {
          bestMatch = { start: matchStart, end: matchEnd, full: match[0] };
          break;
        }
        if (match[2] === selection) {
          const contentStart = matchStart + `<${match[1]}>`.length;
          const dist = Math.abs(cursorStart.ch - contentStart);
          if (dist < bestDistance) {
            bestDistance = dist;
            bestMatch = { start: matchStart, end: matchEnd, full: match[0] };
          }
        }
      }
      if (bestMatch) {
        this.selectionStart = { line: cursorStart.line, ch: bestMatch.start };
        this.selectionEnd = { line: cursorEnd.line, ch: bestMatch.end };
        effectiveSelection = bestMatch.full;
      }
    }
    const currentTag = this.getCurrentTag(effectiveSelection);
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "supsub-popup";
    if (currentTag === "sup" || currentTag === "sub") {
      const normalButton = document.createElement("button");
      normalButton.innerText = "Normal (n)";
      normalButton.setAttribute("aria-label", "Remove superscript/subscript");
      normalButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.wrapSelection(currentTag, editor);
      });
      buttonContainer.appendChild(normalButton);
    } else {
      const supButton = document.createElement("button");
      supButton.innerText = "Sup (\u207F)";
      supButton.setAttribute("aria-label", "Wrap selected text with superscript");
      supButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.wrapSelection("sup", editor);
      });
      const subButton = document.createElement("button");
      subButton.innerText = "Sub (\u2099)";
      subButton.setAttribute("aria-label", "Wrap selected text with subscript");
      subButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.wrapSelection("sub", editor);
      });
      buttonContainer.appendChild(supButton);
      buttonContainer.appendChild(subButton);
    }
    buttonContainer.style.position = "absolute";
    document.body.appendChild(buttonContainer);
    this.positionPopup(buttonContainer, editor);
    requestAnimationFrame(() => {
      buttonContainer.classList.add("visible");
    });
  }
  hideSupSubButtons() {
    const buttonContainers = document.querySelectorAll(".supsub-popup");
    buttonContainers.forEach((buttonContainer) => {
      buttonContainer.classList.remove("visible");
      setTimeout(() => {
        buttonContainer.remove();
      }, 100);
    });
  }
  positionPopup(popup, editor) {
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      const top = rect.bottom + window.scrollY + 5;
      const left = rect.left + rect.width / 2 - popup.offsetWidth / 2;
      const maxLeft = window.innerWidth - popup.offsetWidth - 10;
      const calculatedLeft = Math.max(10, Math.min(left, maxLeft));
      popup.style.top = `${top}px`;
      popup.style.left = `${calculatedLeft}px`;
    }
  }
  wrapSelection(tag, editor) {
    this.isWrapping = true;
    try {
      if (this.selectionStart && this.selectionEnd) {
        const docLines = editor.lineCount();
        const isValidStart = this.selectionStart.line >= 0 && this.selectionStart.line < docLines && this.selectionStart.ch >= 0 && this.selectionStart.ch <= editor.getLine(this.selectionStart.line).length;
        const isValidEnd = this.selectionEnd.line >= 0 && this.selectionEnd.line < docLines && this.selectionEnd.ch >= 0 && this.selectionEnd.ch <= editor.getLine(this.selectionEnd.line).length;
        if (isValidStart && isValidEnd) {
          editor.setSelection(this.selectionStart, this.selectionEnd);
        } else {
          this.selectionStart = null;
          this.selectionEnd = null;
        }
      }
      editor.focus();
      setTimeout(() => {
        try {
          const selection = editor.getSelection();
          if (selection) {
            const regex = new RegExp(`<${tag}>(.*?)</${tag}>`, "s");
            const matches = regex.exec(selection);
            let didWrap = false;
            if (matches) {
              const debracketedSelection = matches[1];
              editor.replaceSelection(debracketedSelection);
              new import_obsidian.Notice(`${tag} tags removed`);
            } else {
              const wrappedSelection = `<${tag}>${selection}</${tag}>`;
              editor.replaceSelection(wrappedSelection);
              new import_obsidian.Notice(`${tag} tags added`);
              didWrap = true;
            }
            this.hideSupSubButtons();
            if (this.settings.hideTags) {
              const cursor = editor.getCursor();
              const lineContent = editor.getLine(cursor.line);
              const optimizedLine = this.optimizeTags(lineContent, tag);
              if (optimizedLine !== lineContent) {
                editor.setLine(cursor.line, optimizedLine);
              }
            }
            const endPos = editor.getCursor("to");
            if (didWrap) {
              const closingTagLen = `</${tag}>`.length;
              const newCursor = { line: endPos.line, ch: endPos.ch - closingTagLen };
              editor.setSelection(newCursor, newCursor);
            } else {
              editor.setSelection(endPos, endPos);
            }
            this.selectionStart = null;
            this.selectionEnd = null;
            editor.scrollIntoView({
              from: editor.getCursor("from"),
              to: editor.getCursor("to")
            });
          }
        } finally {
          this.isWrapping = false;
        }
      }, 50);
    } catch (error) {
      console.error("Error in wrapSelection:", error);
      new import_obsidian.Notice("An error occurred while wrapping selection.");
      this.isWrapping = false;
    }
  }
  optimizeTags(line, tag) {
    const openTag = `<${tag}>`;
    const closeTag = `</${tag}>`;
    let optimizedLine = line.replace(new RegExp(`(${closeTag})(${openTag})`, "g"), "");
    optimizedLine = optimizedLine.replace(new RegExp(`${openTag}\\s*${closeTag}`, "g"), "");
    return optimizedLine;
  }
  getCurrentTag(selection) {
    const supRegex = /^<sup>([\s\S]+)<\/sup>$/i;
    const subRegex = /^<sub>([\s\S]+)<\/sub>$/i;
    if (supRegex.test(selection)) {
      return "sup";
    } else if (subRegex.test(selection)) {
      return "sub";
    } else {
      return null;
    }
  }
  isModifierMatch(evt) {
    const key = this.settings.popupModifierKey;
    if (key === "none")
      return false;
    if (key === "Mod") {
      return evt.key === "Meta" || evt.key === "Control";
    }
    if (key === "Ctrl")
      return evt.key === "Control";
    if (key === "Shift")
      return evt.key === "Shift";
    if (key === "Alt")
      return evt.key === "Alt";
    return false;
  }
  toggleTypingMode(tag, editor) {
    if (this.toggleMode === tag) {
      this.exitToggleMode(editor);
      return;
    }
    if (this.toggleMode) {
      this.exitToggleMode(editor);
    }
    this.toggleMode = tag;
    const cursor = editor.getCursor();
    this.toggleStartLine = cursor.line;
    const openTag = `<${tag}>`;
    editor.replaceRange(openTag, cursor);
    const newCh = cursor.ch + openTag.length;
    editor.setCursor({ line: cursor.line, ch: newCh });
    this.toggleStartPos = newCh;
    this.toggleStatusBarEl = this.addStatusBarItem();
    this.toggleStatusBarEl.setText(tag.toUpperCase());
    this.toggleStatusBarEl.style.cssText = "color: var(--text-accent); font-weight: bold; font-size: 11px; padding: 0 8px; background: var(--background-modifier-hover); border-radius: 4px;";
    new import_obsidian.Notice(`${tag === "sup" ? "Superscript" : "Subscript"} mode activated \u2014 press Escape to exit`);
  }
  exitToggleMode(editor) {
    if (!this.toggleMode)
      return;
    const tag = this.toggleMode;
    const closeTag = `</${tag}>`;
    const cursor = editor.getCursor();
    editor.replaceRange(closeTag, cursor);
    editor.setCursor({ line: cursor.line, ch: cursor.ch + closeTag.length });
    const line = cursor.line;
    const lineContent = editor.getLine(line);
    const optimized = this.optimizeTags(lineContent, tag);
    if (optimized !== lineContent) {
      editor.setLine(line, optimized);
    }
    if (this.toggleStatusBarEl) {
      this.toggleStatusBarEl.remove();
      this.toggleStatusBarEl = null;
    }
    new import_obsidian.Notice(`${tag === "sup" ? "Superscript" : "Subscript"} mode deactivated`);
    this.toggleMode = null;
  }
};
